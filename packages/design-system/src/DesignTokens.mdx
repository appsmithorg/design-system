import { Meta } from '@storybook/blocks';

<Meta title="Design Tokens" />

# Design tokens in ADS

Design tokens enable us to encapsulate our design choices in order to ensure:

- Consistency of styles across the design system
- Remove ambiguity in terms of how to style a UI element.

There are several layers of abstraction at which tokens can be constructed. This document is a proposal to bring alignment between design and engg. teams, in order to meet the above two goals.

Not using the same tokens lead to un-intended consequences of style inconsistencies and mis-communication amongst the team. So, it is essential for us to agree at what level weâ€™d communicate our design choices.

## Token types

| Token Type | Example | Description | Remarks |
| --- | --- | --- | --- |
| Perceptual / core tokens | Gray-500, Orange-600 | Tokens at this level refer to a style property in their primitive state. Using tokens at this level removes burden in remembering the hex value of the color and one could easily refer them with their names. | If one were to change the underlying styles or theme the application - this is where the change needs to happen. For designers and engineers consuming ADS2.0, do not use tokens at this level. |
| Semantic tokens | primary-bg-color, text-muted | These tokens are more meaningful than the core tokens as they are associated with the brand or other semantics. One more layer of abstraction that enables users to easily identify if this is a primary color and not worry about what is the primary shade. | The minimum level at which tokens have to be used in order for people to understand the system. Engineers might come across these tokens in the appsmith repository. If you feel like the usage might be better served with a category token, feel free to replace it.  |
| Component tokens | button-primary-bg-color, textarea-placeholder | These tokens apply to a specific UI component and hence are more relatable in order for one to reason how to style. | Offers full clarity in terms of which token to use, but is too specific and doesnâ€™t scale when new components have to be introduced. Also, requires a token to be created for every component of the system and every time a new component is added to the system. These variables are not set on the root element,so they are scoped to the component they are defined in. |
| Category tokens | ui-content-Modal-heading, ui-control-placeholder, ui-supplementary-info | These tokens apply to a category of components rather than individual components. (More info. below) | Requires some interpretation to understand how an atomic component falls under a category. Easier to apply across a range of components. Easier to relate to. Scales well with new components. Engineers building snowflakes should endeavor to use these tokens.   |

<aside>
  ðŸ’¡ The values of the category tokens are derived from semantic tokens and which are in turn derived from core tokens. Every level derives values from the previous level.
</aside>

## Category tokens

This is a top-down lens which seeks to question what constitutes a UI and categorise them.

![One way to categorise the elements in a UI.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9ad3b133-dccc-4e3f-8f13-d9f43fb0b022/Untitled.png)
One way to categorise the elements in a UI.

At a broad level, we can reason that a UI consists of the following categories:
- Content
- Input controls
- Actions
- Outputs

The idea is to define tokens at this level and ensure that the users of the system are clear in terms of which UI components belong to which categories.

This exercise is needed for atoms and not molecules in a system. Molecules or higher-order components are typically composed of atoms from various categories.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0f358ab8-7d8c-4af2-a95c-f8f4d5b953ea/Untitled.png)

Eg: A Modal could have text, input field, an information block and a call-to-action button. It contains components from all the categories above.

### How does this help with our goals?

ðŸŽ¯Â **Remove ambiguity** By ensuring that we work close to the UI level, it is **easy to identify** the token to use in order to style an element.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/01079165-9693-4000-8a41-fc3dae55944f/Untitled.png)

ðŸŽ¯Â **Consistency of style across components**

<aside>
  ðŸ‘‰ All component atoms **belonging to a category** should use the same style tokens to ensure that they are styled consistently, **unless** this leads to a bad visual design choice.
</aside>

For example:
- The border of an input field should match the border of a checkbox, as they both belong to the category of input controls.
- The border of a secondary button does not have to match the border of an input field, as they belong to different categories.

This generic structure should allow designers and engineers to understand which token to apply, without a lot of interpretation. This method will also scale well in cases when people have to create snowflakes by providing them an easy reference.

<aside>
  ðŸ§µ Category tokens are simpler to use. Learn how to use them in your work.

  [How to style using design tokens](https://www.notion.so/How-to-style-using-design-tokens-fcc35bf74ce14083962704be5b3939cd?pvs=21)

</aside>

In the cases that this doesn't work - we have semantic tokens that provide more stylistic control for one to achieve in their design projects.
